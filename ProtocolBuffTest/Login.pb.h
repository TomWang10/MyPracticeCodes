// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Login.proto

#ifndef PROTOBUF_Login_2eproto__INCLUDED
#define PROTOBUF_Login_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Test {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Login_2eproto();
void protobuf_AssignDesc_Login_2eproto();
void protobuf_ShutdownFile_Login_2eproto();

class RetLogin;

// ===================================================================

class RetLogin : public ::google::protobuf::Message {
 public:
  RetLogin();
  virtual ~RetLogin();

  RetLogin(const RetLogin& from);

  inline RetLogin& operator=(const RetLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetLogin& default_instance();

  void Swap(RetLogin* other);

  // implements Message ----------------------------------------------

  RetLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetLogin& from);
  void MergeFrom(const RetLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 sblx = 1;
  inline bool has_sblx() const;
  inline void clear_sblx();
  static const int kSblxFieldNumber = 1;
  inline ::google::protobuf::int32 sblx() const;
  inline void set_sblx(::google::protobuf::int32 value);

  // required string sjhm = 2;
  inline bool has_sjhm() const;
  inline void clear_sjhm();
  static const int kSjhmFieldNumber = 2;
  inline const ::std::string& sjhm() const;
  inline void set_sjhm(const ::std::string& value);
  inline void set_sjhm(const char* value);
  inline void set_sjhm(const char* value, size_t size);
  inline ::std::string* mutable_sjhm();
  inline ::std::string* release_sjhm();
  inline void set_allocated_sjhm(::std::string* sjhm);

  // required string yjxx = 3;
  inline bool has_yjxx() const;
  inline void clear_yjxx();
  static const int kYjxxFieldNumber = 3;
  inline const ::std::string& yjxx() const;
  inline void set_yjxx(const ::std::string& value);
  inline void set_yjxx(const char* value);
  inline void set_yjxx(const char* value, size_t size);
  inline ::std::string* mutable_yjxx();
  inline ::std::string* release_yjxx();
  inline void set_allocated_yjxx(::std::string* yjxx);

  // required string jymm = 4;
  inline bool has_jymm() const;
  inline void clear_jymm();
  static const int kJymmFieldNumber = 4;
  inline const ::std::string& jymm() const;
  inline void set_jymm(const ::std::string& value);
  inline void set_jymm(const char* value);
  inline void set_jymm(const char* value, size_t size);
  inline ::std::string* mutable_jymm();
  inline ::std::string* release_jymm();
  inline void set_allocated_jymm(::std::string* jymm);

  // required string syspm1 = 5;
  inline bool has_syspm1() const;
  inline void clear_syspm1();
  static const int kSyspm1FieldNumber = 5;
  inline const ::std::string& syspm1() const;
  inline void set_syspm1(const ::std::string& value);
  inline void set_syspm1(const char* value);
  inline void set_syspm1(const char* value, size_t size);
  inline ::std::string* mutable_syspm1();
  inline ::std::string* release_syspm1();
  inline void set_allocated_syspm1(::std::string* syspm1);

  // required string syspm2 = 6;
  inline bool has_syspm2() const;
  inline void clear_syspm2();
  static const int kSyspm2FieldNumber = 6;
  inline const ::std::string& syspm2() const;
  inline void set_syspm2(const ::std::string& value);
  inline void set_syspm2(const char* value);
  inline void set_syspm2(const char* value, size_t size);
  inline ::std::string* mutable_syspm2();
  inline ::std::string* release_syspm2();
  inline void set_allocated_syspm2(::std::string* syspm2);

  // required string syspm3 = 7;
  inline bool has_syspm3() const;
  inline void clear_syspm3();
  static const int kSyspm3FieldNumber = 7;
  inline const ::std::string& syspm3() const;
  inline void set_syspm3(const ::std::string& value);
  inline void set_syspm3(const char* value);
  inline void set_syspm3(const char* value, size_t size);
  inline ::std::string* mutable_syspm3();
  inline ::std::string* release_syspm3();
  inline void set_allocated_syspm3(::std::string* syspm3);

  // required string syspm_ex = 8;
  inline bool has_syspm_ex() const;
  inline void clear_syspm_ex();
  static const int kSyspmExFieldNumber = 8;
  inline const ::std::string& syspm_ex() const;
  inline void set_syspm_ex(const ::std::string& value);
  inline void set_syspm_ex(const char* value);
  inline void set_syspm_ex(const char* value, size_t size);
  inline ::std::string* mutable_syspm_ex();
  inline ::std::string* release_syspm_ex();
  inline void set_allocated_syspm_ex(::std::string* syspm_ex);

  // required string type = 9;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string yybdm = 10;
  inline bool has_yybdm() const;
  inline void clear_yybdm();
  static const int kYybdmFieldNumber = 10;
  inline const ::std::string& yybdm() const;
  inline void set_yybdm(const ::std::string& value);
  inline void set_yybdm(const char* value);
  inline void set_yybdm(const char* value, size_t size);
  inline ::std::string* mutable_yybdm();
  inline ::std::string* release_yybdm();
  inline void set_allocated_yybdm(::std::string* yybdm);

  // required string user_id_lx = 11;
  inline bool has_user_id_lx() const;
  inline void clear_user_id_lx();
  static const int kUserIdLxFieldNumber = 11;
  inline const ::std::string& user_id_lx() const;
  inline void set_user_id_lx(const ::std::string& value);
  inline void set_user_id_lx(const char* value);
  inline void set_user_id_lx(const char* value, size_t size);
  inline ::std::string* mutable_user_id_lx();
  inline ::std::string* release_user_id_lx();
  inline void set_allocated_user_id_lx(::std::string* user_id_lx);

  // required string user_id = 12;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 12;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // required string ex_pwd = 13;
  inline bool has_ex_pwd() const;
  inline void clear_ex_pwd();
  static const int kExPwdFieldNumber = 13;
  inline const ::std::string& ex_pwd() const;
  inline void set_ex_pwd(const ::std::string& value);
  inline void set_ex_pwd(const char* value);
  inline void set_ex_pwd(const char* value, size_t size);
  inline ::std::string* mutable_ex_pwd();
  inline ::std::string* release_ex_pwd();
  inline void set_allocated_ex_pwd(::std::string* ex_pwd);

  // @@protoc_insertion_point(class_scope:Test.RetLogin)
 private:
  inline void set_has_sblx();
  inline void clear_has_sblx();
  inline void set_has_sjhm();
  inline void clear_has_sjhm();
  inline void set_has_yjxx();
  inline void clear_has_yjxx();
  inline void set_has_jymm();
  inline void clear_has_jymm();
  inline void set_has_syspm1();
  inline void clear_has_syspm1();
  inline void set_has_syspm2();
  inline void clear_has_syspm2();
  inline void set_has_syspm3();
  inline void clear_has_syspm3();
  inline void set_has_syspm_ex();
  inline void clear_has_syspm_ex();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_yybdm();
  inline void clear_has_yybdm();
  inline void set_has_user_id_lx();
  inline void clear_has_user_id_lx();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_ex_pwd();
  inline void clear_has_ex_pwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sjhm_;
  ::std::string* yjxx_;
  ::std::string* jymm_;
  ::std::string* syspm1_;
  ::std::string* syspm2_;
  ::std::string* syspm3_;
  ::std::string* syspm_ex_;
  ::std::string* type_;
  ::std::string* yybdm_;
  ::std::string* user_id_lx_;
  ::std::string* user_id_;
  ::std::string* ex_pwd_;
  ::google::protobuf::int32 sblx_;
  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static RetLogin* default_instance_;
};
// ===================================================================


// ===================================================================

// RetLogin

// required int32 sblx = 1;
inline bool RetLogin::has_sblx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetLogin::set_has_sblx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetLogin::clear_has_sblx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetLogin::clear_sblx() {
  sblx_ = 0;
  clear_has_sblx();
}
inline ::google::protobuf::int32 RetLogin::sblx() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.sblx)
  return sblx_;
}
inline void RetLogin::set_sblx(::google::protobuf::int32 value) {
  set_has_sblx();
  sblx_ = value;
  // @@protoc_insertion_point(field_set:Test.RetLogin.sblx)
}

// required string sjhm = 2;
inline bool RetLogin::has_sjhm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetLogin::set_has_sjhm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetLogin::clear_has_sjhm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetLogin::clear_sjhm() {
  if (sjhm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sjhm_->clear();
  }
  clear_has_sjhm();
}
inline const ::std::string& RetLogin::sjhm() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.sjhm)
  return *sjhm_;
}
inline void RetLogin::set_sjhm(const ::std::string& value) {
  set_has_sjhm();
  if (sjhm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sjhm_ = new ::std::string;
  }
  sjhm_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.sjhm)
}
inline void RetLogin::set_sjhm(const char* value) {
  set_has_sjhm();
  if (sjhm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sjhm_ = new ::std::string;
  }
  sjhm_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.sjhm)
}
inline void RetLogin::set_sjhm(const char* value, size_t size) {
  set_has_sjhm();
  if (sjhm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sjhm_ = new ::std::string;
  }
  sjhm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.sjhm)
}
inline ::std::string* RetLogin::mutable_sjhm() {
  set_has_sjhm();
  if (sjhm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sjhm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.sjhm)
  return sjhm_;
}
inline ::std::string* RetLogin::release_sjhm() {
  clear_has_sjhm();
  if (sjhm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sjhm_;
    sjhm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_sjhm(::std::string* sjhm) {
  if (sjhm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sjhm_;
  }
  if (sjhm) {
    set_has_sjhm();
    sjhm_ = sjhm;
  } else {
    clear_has_sjhm();
    sjhm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.sjhm)
}

// required string yjxx = 3;
inline bool RetLogin::has_yjxx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetLogin::set_has_yjxx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetLogin::clear_has_yjxx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetLogin::clear_yjxx() {
  if (yjxx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yjxx_->clear();
  }
  clear_has_yjxx();
}
inline const ::std::string& RetLogin::yjxx() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.yjxx)
  return *yjxx_;
}
inline void RetLogin::set_yjxx(const ::std::string& value) {
  set_has_yjxx();
  if (yjxx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yjxx_ = new ::std::string;
  }
  yjxx_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.yjxx)
}
inline void RetLogin::set_yjxx(const char* value) {
  set_has_yjxx();
  if (yjxx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yjxx_ = new ::std::string;
  }
  yjxx_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.yjxx)
}
inline void RetLogin::set_yjxx(const char* value, size_t size) {
  set_has_yjxx();
  if (yjxx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yjxx_ = new ::std::string;
  }
  yjxx_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.yjxx)
}
inline ::std::string* RetLogin::mutable_yjxx() {
  set_has_yjxx();
  if (yjxx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yjxx_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.yjxx)
  return yjxx_;
}
inline ::std::string* RetLogin::release_yjxx() {
  clear_has_yjxx();
  if (yjxx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = yjxx_;
    yjxx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_yjxx(::std::string* yjxx) {
  if (yjxx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete yjxx_;
  }
  if (yjxx) {
    set_has_yjxx();
    yjxx_ = yjxx;
  } else {
    clear_has_yjxx();
    yjxx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.yjxx)
}

// required string jymm = 4;
inline bool RetLogin::has_jymm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RetLogin::set_has_jymm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RetLogin::clear_has_jymm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RetLogin::clear_jymm() {
  if (jymm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jymm_->clear();
  }
  clear_has_jymm();
}
inline const ::std::string& RetLogin::jymm() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.jymm)
  return *jymm_;
}
inline void RetLogin::set_jymm(const ::std::string& value) {
  set_has_jymm();
  if (jymm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jymm_ = new ::std::string;
  }
  jymm_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.jymm)
}
inline void RetLogin::set_jymm(const char* value) {
  set_has_jymm();
  if (jymm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jymm_ = new ::std::string;
  }
  jymm_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.jymm)
}
inline void RetLogin::set_jymm(const char* value, size_t size) {
  set_has_jymm();
  if (jymm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jymm_ = new ::std::string;
  }
  jymm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.jymm)
}
inline ::std::string* RetLogin::mutable_jymm() {
  set_has_jymm();
  if (jymm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jymm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.jymm)
  return jymm_;
}
inline ::std::string* RetLogin::release_jymm() {
  clear_has_jymm();
  if (jymm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = jymm_;
    jymm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_jymm(::std::string* jymm) {
  if (jymm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete jymm_;
  }
  if (jymm) {
    set_has_jymm();
    jymm_ = jymm;
  } else {
    clear_has_jymm();
    jymm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.jymm)
}

// required string syspm1 = 5;
inline bool RetLogin::has_syspm1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RetLogin::set_has_syspm1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RetLogin::clear_has_syspm1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RetLogin::clear_syspm1() {
  if (syspm1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm1_->clear();
  }
  clear_has_syspm1();
}
inline const ::std::string& RetLogin::syspm1() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.syspm1)
  return *syspm1_;
}
inline void RetLogin::set_syspm1(const ::std::string& value) {
  set_has_syspm1();
  if (syspm1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm1_ = new ::std::string;
  }
  syspm1_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.syspm1)
}
inline void RetLogin::set_syspm1(const char* value) {
  set_has_syspm1();
  if (syspm1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm1_ = new ::std::string;
  }
  syspm1_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.syspm1)
}
inline void RetLogin::set_syspm1(const char* value, size_t size) {
  set_has_syspm1();
  if (syspm1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm1_ = new ::std::string;
  }
  syspm1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.syspm1)
}
inline ::std::string* RetLogin::mutable_syspm1() {
  set_has_syspm1();
  if (syspm1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.syspm1)
  return syspm1_;
}
inline ::std::string* RetLogin::release_syspm1() {
  clear_has_syspm1();
  if (syspm1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = syspm1_;
    syspm1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_syspm1(::std::string* syspm1) {
  if (syspm1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete syspm1_;
  }
  if (syspm1) {
    set_has_syspm1();
    syspm1_ = syspm1;
  } else {
    clear_has_syspm1();
    syspm1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.syspm1)
}

// required string syspm2 = 6;
inline bool RetLogin::has_syspm2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RetLogin::set_has_syspm2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RetLogin::clear_has_syspm2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RetLogin::clear_syspm2() {
  if (syspm2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm2_->clear();
  }
  clear_has_syspm2();
}
inline const ::std::string& RetLogin::syspm2() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.syspm2)
  return *syspm2_;
}
inline void RetLogin::set_syspm2(const ::std::string& value) {
  set_has_syspm2();
  if (syspm2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm2_ = new ::std::string;
  }
  syspm2_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.syspm2)
}
inline void RetLogin::set_syspm2(const char* value) {
  set_has_syspm2();
  if (syspm2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm2_ = new ::std::string;
  }
  syspm2_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.syspm2)
}
inline void RetLogin::set_syspm2(const char* value, size_t size) {
  set_has_syspm2();
  if (syspm2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm2_ = new ::std::string;
  }
  syspm2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.syspm2)
}
inline ::std::string* RetLogin::mutable_syspm2() {
  set_has_syspm2();
  if (syspm2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.syspm2)
  return syspm2_;
}
inline ::std::string* RetLogin::release_syspm2() {
  clear_has_syspm2();
  if (syspm2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = syspm2_;
    syspm2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_syspm2(::std::string* syspm2) {
  if (syspm2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete syspm2_;
  }
  if (syspm2) {
    set_has_syspm2();
    syspm2_ = syspm2;
  } else {
    clear_has_syspm2();
    syspm2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.syspm2)
}

// required string syspm3 = 7;
inline bool RetLogin::has_syspm3() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RetLogin::set_has_syspm3() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RetLogin::clear_has_syspm3() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RetLogin::clear_syspm3() {
  if (syspm3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm3_->clear();
  }
  clear_has_syspm3();
}
inline const ::std::string& RetLogin::syspm3() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.syspm3)
  return *syspm3_;
}
inline void RetLogin::set_syspm3(const ::std::string& value) {
  set_has_syspm3();
  if (syspm3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm3_ = new ::std::string;
  }
  syspm3_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.syspm3)
}
inline void RetLogin::set_syspm3(const char* value) {
  set_has_syspm3();
  if (syspm3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm3_ = new ::std::string;
  }
  syspm3_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.syspm3)
}
inline void RetLogin::set_syspm3(const char* value, size_t size) {
  set_has_syspm3();
  if (syspm3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm3_ = new ::std::string;
  }
  syspm3_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.syspm3)
}
inline ::std::string* RetLogin::mutable_syspm3() {
  set_has_syspm3();
  if (syspm3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm3_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.syspm3)
  return syspm3_;
}
inline ::std::string* RetLogin::release_syspm3() {
  clear_has_syspm3();
  if (syspm3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = syspm3_;
    syspm3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_syspm3(::std::string* syspm3) {
  if (syspm3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete syspm3_;
  }
  if (syspm3) {
    set_has_syspm3();
    syspm3_ = syspm3;
  } else {
    clear_has_syspm3();
    syspm3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.syspm3)
}

// required string syspm_ex = 8;
inline bool RetLogin::has_syspm_ex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RetLogin::set_has_syspm_ex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RetLogin::clear_has_syspm_ex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RetLogin::clear_syspm_ex() {
  if (syspm_ex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm_ex_->clear();
  }
  clear_has_syspm_ex();
}
inline const ::std::string& RetLogin::syspm_ex() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.syspm_ex)
  return *syspm_ex_;
}
inline void RetLogin::set_syspm_ex(const ::std::string& value) {
  set_has_syspm_ex();
  if (syspm_ex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm_ex_ = new ::std::string;
  }
  syspm_ex_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.syspm_ex)
}
inline void RetLogin::set_syspm_ex(const char* value) {
  set_has_syspm_ex();
  if (syspm_ex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm_ex_ = new ::std::string;
  }
  syspm_ex_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.syspm_ex)
}
inline void RetLogin::set_syspm_ex(const char* value, size_t size) {
  set_has_syspm_ex();
  if (syspm_ex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm_ex_ = new ::std::string;
  }
  syspm_ex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.syspm_ex)
}
inline ::std::string* RetLogin::mutable_syspm_ex() {
  set_has_syspm_ex();
  if (syspm_ex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    syspm_ex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.syspm_ex)
  return syspm_ex_;
}
inline ::std::string* RetLogin::release_syspm_ex() {
  clear_has_syspm_ex();
  if (syspm_ex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = syspm_ex_;
    syspm_ex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_syspm_ex(::std::string* syspm_ex) {
  if (syspm_ex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete syspm_ex_;
  }
  if (syspm_ex) {
    set_has_syspm_ex();
    syspm_ex_ = syspm_ex;
  } else {
    clear_has_syspm_ex();
    syspm_ex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.syspm_ex)
}

// required string type = 9;
inline bool RetLogin::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RetLogin::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RetLogin::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RetLogin::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RetLogin::type() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.type)
  return *type_;
}
inline void RetLogin::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.type)
}
inline void RetLogin::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.type)
}
inline void RetLogin::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.type)
}
inline ::std::string* RetLogin::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.type)
  return type_;
}
inline ::std::string* RetLogin::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.type)
}

// required string yybdm = 10;
inline bool RetLogin::has_yybdm() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RetLogin::set_has_yybdm() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RetLogin::clear_has_yybdm() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RetLogin::clear_yybdm() {
  if (yybdm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yybdm_->clear();
  }
  clear_has_yybdm();
}
inline const ::std::string& RetLogin::yybdm() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.yybdm)
  return *yybdm_;
}
inline void RetLogin::set_yybdm(const ::std::string& value) {
  set_has_yybdm();
  if (yybdm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yybdm_ = new ::std::string;
  }
  yybdm_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.yybdm)
}
inline void RetLogin::set_yybdm(const char* value) {
  set_has_yybdm();
  if (yybdm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yybdm_ = new ::std::string;
  }
  yybdm_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.yybdm)
}
inline void RetLogin::set_yybdm(const char* value, size_t size) {
  set_has_yybdm();
  if (yybdm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yybdm_ = new ::std::string;
  }
  yybdm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.yybdm)
}
inline ::std::string* RetLogin::mutable_yybdm() {
  set_has_yybdm();
  if (yybdm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yybdm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.yybdm)
  return yybdm_;
}
inline ::std::string* RetLogin::release_yybdm() {
  clear_has_yybdm();
  if (yybdm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = yybdm_;
    yybdm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_yybdm(::std::string* yybdm) {
  if (yybdm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete yybdm_;
  }
  if (yybdm) {
    set_has_yybdm();
    yybdm_ = yybdm;
  } else {
    clear_has_yybdm();
    yybdm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.yybdm)
}

// required string user_id_lx = 11;
inline bool RetLogin::has_user_id_lx() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RetLogin::set_has_user_id_lx() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RetLogin::clear_has_user_id_lx() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RetLogin::clear_user_id_lx() {
  if (user_id_lx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_lx_->clear();
  }
  clear_has_user_id_lx();
}
inline const ::std::string& RetLogin::user_id_lx() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.user_id_lx)
  return *user_id_lx_;
}
inline void RetLogin::set_user_id_lx(const ::std::string& value) {
  set_has_user_id_lx();
  if (user_id_lx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_lx_ = new ::std::string;
  }
  user_id_lx_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.user_id_lx)
}
inline void RetLogin::set_user_id_lx(const char* value) {
  set_has_user_id_lx();
  if (user_id_lx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_lx_ = new ::std::string;
  }
  user_id_lx_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.user_id_lx)
}
inline void RetLogin::set_user_id_lx(const char* value, size_t size) {
  set_has_user_id_lx();
  if (user_id_lx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_lx_ = new ::std::string;
  }
  user_id_lx_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.user_id_lx)
}
inline ::std::string* RetLogin::mutable_user_id_lx() {
  set_has_user_id_lx();
  if (user_id_lx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_lx_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.user_id_lx)
  return user_id_lx_;
}
inline ::std::string* RetLogin::release_user_id_lx() {
  clear_has_user_id_lx();
  if (user_id_lx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_id_lx_;
    user_id_lx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_user_id_lx(::std::string* user_id_lx) {
  if (user_id_lx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_id_lx_;
  }
  if (user_id_lx) {
    set_has_user_id_lx();
    user_id_lx_ = user_id_lx;
  } else {
    clear_has_user_id_lx();
    user_id_lx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.user_id_lx)
}

// required string user_id = 12;
inline bool RetLogin::has_user_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RetLogin::set_has_user_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RetLogin::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RetLogin::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& RetLogin::user_id() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.user_id)
  return *user_id_;
}
inline void RetLogin::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.user_id)
}
inline void RetLogin::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.user_id)
}
inline void RetLogin::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.user_id)
}
inline ::std::string* RetLogin::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.user_id)
  return user_id_;
}
inline ::std::string* RetLogin::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.user_id)
}

// required string ex_pwd = 13;
inline bool RetLogin::has_ex_pwd() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RetLogin::set_has_ex_pwd() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RetLogin::clear_has_ex_pwd() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RetLogin::clear_ex_pwd() {
  if (ex_pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ex_pwd_->clear();
  }
  clear_has_ex_pwd();
}
inline const ::std::string& RetLogin::ex_pwd() const {
  // @@protoc_insertion_point(field_get:Test.RetLogin.ex_pwd)
  return *ex_pwd_;
}
inline void RetLogin::set_ex_pwd(const ::std::string& value) {
  set_has_ex_pwd();
  if (ex_pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ex_pwd_ = new ::std::string;
  }
  ex_pwd_->assign(value);
  // @@protoc_insertion_point(field_set:Test.RetLogin.ex_pwd)
}
inline void RetLogin::set_ex_pwd(const char* value) {
  set_has_ex_pwd();
  if (ex_pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ex_pwd_ = new ::std::string;
  }
  ex_pwd_->assign(value);
  // @@protoc_insertion_point(field_set_char:Test.RetLogin.ex_pwd)
}
inline void RetLogin::set_ex_pwd(const char* value, size_t size) {
  set_has_ex_pwd();
  if (ex_pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ex_pwd_ = new ::std::string;
  }
  ex_pwd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Test.RetLogin.ex_pwd)
}
inline ::std::string* RetLogin::mutable_ex_pwd() {
  set_has_ex_pwd();
  if (ex_pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ex_pwd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Test.RetLogin.ex_pwd)
  return ex_pwd_;
}
inline ::std::string* RetLogin::release_ex_pwd() {
  clear_has_ex_pwd();
  if (ex_pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ex_pwd_;
    ex_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetLogin::set_allocated_ex_pwd(::std::string* ex_pwd) {
  if (ex_pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ex_pwd_;
  }
  if (ex_pwd) {
    set_has_ex_pwd();
    ex_pwd_ = ex_pwd;
  } else {
    clear_has_ex_pwd();
    ex_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Test.RetLogin.ex_pwd)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Test

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Login_2eproto__INCLUDED
